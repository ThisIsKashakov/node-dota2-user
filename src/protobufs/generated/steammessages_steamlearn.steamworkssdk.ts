// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.4.1
//   protoc               v5.28.3
// source: steammessages_steamlearn.steamworkssdk.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export enum ESteamLearnDataType {
  STEAMLEARN_DATATYPE_INVALID = 0,
  STEAMLEARN_DATATYPE_INT32 = 1,
  STEAMLEARN_DATATYPE_FLOAT32 = 2,
  STEAMLEARN_DATATYPE_BOOL = 3,
  STEAMLEARN_DATATYPE_STRING = 4,
  STEAMLEARN_DATATYPE_OBJECT = 5,
}

export function eSteamLearnDataTypeFromJSON(object: any): ESteamLearnDataType {
  switch (object) {
    case 0:
    case "STEAMLEARN_DATATYPE_INVALID":
      return ESteamLearnDataType.STEAMLEARN_DATATYPE_INVALID;
    case 1:
    case "STEAMLEARN_DATATYPE_INT32":
      return ESteamLearnDataType.STEAMLEARN_DATATYPE_INT32;
    case 2:
    case "STEAMLEARN_DATATYPE_FLOAT32":
      return ESteamLearnDataType.STEAMLEARN_DATATYPE_FLOAT32;
    case 3:
    case "STEAMLEARN_DATATYPE_BOOL":
      return ESteamLearnDataType.STEAMLEARN_DATATYPE_BOOL;
    case 4:
    case "STEAMLEARN_DATATYPE_STRING":
      return ESteamLearnDataType.STEAMLEARN_DATATYPE_STRING;
    case 5:
    case "STEAMLEARN_DATATYPE_OBJECT":
      return ESteamLearnDataType.STEAMLEARN_DATATYPE_OBJECT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnDataType");
  }
}

export function eSteamLearnDataTypeToJSON(object: ESteamLearnDataType): string {
  switch (object) {
    case ESteamLearnDataType.STEAMLEARN_DATATYPE_INVALID:
      return "STEAMLEARN_DATATYPE_INVALID";
    case ESteamLearnDataType.STEAMLEARN_DATATYPE_INT32:
      return "STEAMLEARN_DATATYPE_INT32";
    case ESteamLearnDataType.STEAMLEARN_DATATYPE_FLOAT32:
      return "STEAMLEARN_DATATYPE_FLOAT32";
    case ESteamLearnDataType.STEAMLEARN_DATATYPE_BOOL:
      return "STEAMLEARN_DATATYPE_BOOL";
    case ESteamLearnDataType.STEAMLEARN_DATATYPE_STRING:
      return "STEAMLEARN_DATATYPE_STRING";
    case ESteamLearnDataType.STEAMLEARN_DATATYPE_OBJECT:
      return "STEAMLEARN_DATATYPE_OBJECT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnDataType");
  }
}

export enum ESteammLearnRegisterDataSourceResult {
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR = 0,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED = 1,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND = 2,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC = 3,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME = 4,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION = 5,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED = 6,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID = 7,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN = 8,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP = 9,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED = 10,
}

export function eSteammLearnRegisterDataSourceResultFromJSON(object: any): ESteammLearnRegisterDataSourceResult {
  switch (object) {
    case 0:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR;
    case 1:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED;
    case 2:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND;
    case 3:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC;
    case 4:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME;
    case 5:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION;
    case 6:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED;
    case 7:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID;
    case 8:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN;
    case 9:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP;
    case 10:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum ESteammLearnRegisterDataSourceResult",
      );
  }
}

export function eSteammLearnRegisterDataSourceResultToJSON(object: ESteammLearnRegisterDataSourceResult): string {
  switch (object) {
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum ESteammLearnRegisterDataSourceResult",
      );
  }
}

export enum ESteamLearnCacheDataResult {
  STEAMLEARN_CACHE_DATA_ERROR = 0,
  STEAMLEARN_CACHE_DATA_SUCCESS = 1,
  STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE = 2,
  STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE = 3,
  STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS = 4,
  STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN = 5,
  STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP = 6,
  STEAMLEARN_CACHE_DATA_DISABLED = 7,
}

export function eSteamLearnCacheDataResultFromJSON(object: any): ESteamLearnCacheDataResult {
  switch (object) {
    case 0:
    case "STEAMLEARN_CACHE_DATA_ERROR":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR;
    case 1:
    case "STEAMLEARN_CACHE_DATA_SUCCESS":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_SUCCESS;
    case 2:
    case "STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE;
    case 3:
    case "STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE;
    case 4:
    case "STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS;
    case 5:
    case "STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN;
    case 6:
    case "STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP;
    case 7:
    case "STEAMLEARN_CACHE_DATA_DISABLED":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_DISABLED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnCacheDataResult");
  }
}

export function eSteamLearnCacheDataResultToJSON(object: ESteamLearnCacheDataResult): string {
  switch (object) {
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR:
      return "STEAMLEARN_CACHE_DATA_ERROR";
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_SUCCESS:
      return "STEAMLEARN_CACHE_DATA_SUCCESS";
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE:
      return "STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE";
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE:
      return "STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE";
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS:
      return "STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS";
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN:
      return "STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN";
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP:
      return "STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP";
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_DISABLED:
      return "STEAMLEARN_CACHE_DATA_DISABLED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnCacheDataResult");
  }
}

export enum ESteamLearnSnapshotProjectResult {
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR = 0,
  STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED = 1,
  STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED = 2,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID = 3,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE = 4,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY = 5,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION = 6,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG = 7,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN = 8,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP = 9,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR = 10,
  STEAMLEARN_SNAPSHOT_PROJECT_DISABLED = 11,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION = 12,
}

export function eSteamLearnSnapshotProjectResultFromJSON(object: any): ESteamLearnSnapshotProjectResult {
  switch (object) {
    case 0:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR;
    case 1:
    case "STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED;
    case 2:
    case "STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED;
    case 3:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID;
    case 4:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE;
    case 5:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY;
    case 6:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION;
    case 7:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG;
    case 8:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN;
    case 9:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP;
    case 10:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR;
    case 11:
    case "STEAMLEARN_SNAPSHOT_PROJECT_DISABLED":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_DISABLED;
    case 12:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnSnapshotProjectResult");
  }
}

export function eSteamLearnSnapshotProjectResultToJSON(object: ESteamLearnSnapshotProjectResult): string {
  switch (object) {
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED:
      return "STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED:
      return "STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_DISABLED:
      return "STEAMLEARN_SNAPSHOT_PROJECT_DISABLED";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnSnapshotProjectResult");
  }
}

export enum ESteamLearnGetHMACKeysResult {
  STEAMLEARN_GET_HMAC_KEYS_SUCCESS = 0,
}

export function eSteamLearnGetHMACKeysResultFromJSON(object: any): ESteamLearnGetHMACKeysResult {
  switch (object) {
    case 0:
    case "STEAMLEARN_GET_HMAC_KEYS_SUCCESS":
      return ESteamLearnGetHMACKeysResult.STEAMLEARN_GET_HMAC_KEYS_SUCCESS;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnGetHMACKeysResult");
  }
}

export function eSteamLearnGetHMACKeysResultToJSON(object: ESteamLearnGetHMACKeysResult): string {
  switch (object) {
    case ESteamLearnGetHMACKeysResult.STEAMLEARN_GET_HMAC_KEYS_SUCCESS:
      return "STEAMLEARN_GET_HMAC_KEYS_SUCCESS";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnGetHMACKeysResult");
  }
}

export enum ESteamLearnInferenceResult {
  STEAMLEARN_INFERENCE_ERROR = 0,
  STEAMLEARN_INFERENCE_SUCCESS = 1,
  STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID = 2,
  STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA = 3,
  STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG = 4,
  STEAMLEARN_INFERENCE_ERROR_FORBIDDEN = 5,
  STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP = 6,
  STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION = 7,
  STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND = 8,
  STEAMLEARN_INFERENCE_ERROR_TOO_BUSY = 9,
}

export function eSteamLearnInferenceResultFromJSON(object: any): ESteamLearnInferenceResult {
  switch (object) {
    case 0:
    case "STEAMLEARN_INFERENCE_ERROR":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR;
    case 1:
    case "STEAMLEARN_INFERENCE_SUCCESS":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_SUCCESS;
    case 2:
    case "STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID;
    case 3:
    case "STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA;
    case 4:
    case "STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG;
    case 5:
    case "STEAMLEARN_INFERENCE_ERROR_FORBIDDEN":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_FORBIDDEN;
    case 6:
    case "STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP;
    case 7:
    case "STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION;
    case 8:
    case "STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND;
    case 9:
    case "STEAMLEARN_INFERENCE_ERROR_TOO_BUSY":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_TOO_BUSY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnInferenceResult");
  }
}

export function eSteamLearnInferenceResultToJSON(object: ESteamLearnInferenceResult): string {
  switch (object) {
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR:
      return "STEAMLEARN_INFERENCE_ERROR";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_SUCCESS:
      return "STEAMLEARN_INFERENCE_SUCCESS";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID:
      return "STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA:
      return "STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG:
      return "STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_FORBIDDEN:
      return "STEAMLEARN_INFERENCE_ERROR_FORBIDDEN";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP:
      return "STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION:
      return "STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND:
      return "STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_TOO_BUSY:
      return "STEAMLEARN_INFERENCE_ERROR_TOO_BUSY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnInferenceResult");
  }
}

export enum ESteamLearnInferenceMetadataResult {
  STEAMLEARN_INFERENCE_METADATA_ERROR = 0,
  STEAMLEARN_INFERENCE_METADATA_SUCCESS = 1,
  STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID = 2,
  STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG = 3,
  STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN = 4,
  STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP = 5,
  STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION = 6,
  STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND = 7,
}

export function eSteamLearnInferenceMetadataResultFromJSON(object: any): ESteamLearnInferenceMetadataResult {
  switch (object) {
    case 0:
    case "STEAMLEARN_INFERENCE_METADATA_ERROR":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR;
    case 1:
    case "STEAMLEARN_INFERENCE_METADATA_SUCCESS":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_SUCCESS;
    case 2:
    case "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID;
    case 3:
    case "STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG;
    case 4:
    case "STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN;
    case 5:
    case "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP;
    case 6:
    case "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION;
    case 7:
    case "STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnInferenceMetadataResult");
  }
}

export function eSteamLearnInferenceMetadataResultToJSON(object: ESteamLearnInferenceMetadataResult): string {
  switch (object) {
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR:
      return "STEAMLEARN_INFERENCE_METADATA_ERROR";
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_SUCCESS:
      return "STEAMLEARN_INFERENCE_METADATA_SUCCESS";
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID:
      return "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID";
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG:
      return "STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG";
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN:
      return "STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN";
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP:
      return "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP";
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION:
      return "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION";
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND:
      return "STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnInferenceMetadataResult");
  }
}

export interface CMsgSteamLearnDataSourceDescObject {
  elements: CMsgSteamLearnDataSourceDescElement[];
}

export interface CMsgSteamLearnDataSourceDescElement {
  name: string;
  dataType: ESteamLearnDataType;
  object: CMsgSteamLearnDataSourceDescObject | undefined;
  count: number;
}

export interface CMsgSteamLearnDataSource {
  id: number;
  name: string;
  version: number;
  sourceDescription: string;
  structure: CMsgSteamLearnDataSourceDescObject | undefined;
  structureCrc: number;
  cacheDurationSeconds: number;
}

export interface CMsgSteamLearnDataObject {
  elements: CMsgSteamLearnDataElement[];
}

export interface CMsgSteamLearnDataElement {
  name: string;
  dataInt32s: number[];
  dataFloats: number[];
  dataBools: boolean[];
  dataStrings: string[];
  dataObjects: CMsgSteamLearnDataObject[];
}

export interface CMsgSteamLearnData {
  dataSourceId: number;
  keys: string[];
  dataObject: CMsgSteamLearnDataObject | undefined;
}

export interface CMsgSteamLearnDataList {
  data: CMsgSteamLearnData[];
}

export interface CMsgSteamLearnAccessData {
  publisherId: number;
  timestamp: number;
  randomValue: string;
}

export interface CMsgSteamLearnRegisterDataSourceRequest {
  accessToken: string;
  accessData: CMsgSteamLearnAccessData | undefined;
  dataSource: CMsgSteamLearnDataSource | undefined;
}

export interface CMsgSteamLearnRegisterDataSourceResponse {
  result: ESteammLearnRegisterDataSourceResult;
  dataSource: CMsgSteamLearnDataSource | undefined;
}

export interface CMsgSteamLearnCacheDataRequest {
  accessToken: string;
  accessData: CMsgSteamLearnAccessData | undefined;
  data: CMsgSteamLearnData | undefined;
}

export interface CMsgSteamLearnCacheDataResponse {
  cacheDataResult: ESteamLearnCacheDataResult;
}

export interface CMsgSteamLearnSnapshotProjectRequest {
  accessToken: string;
  accessData: CMsgSteamLearnAccessData | undefined;
  projectId: number;
  publishedVersion: number;
  keys: string[];
  data: CMsgSteamLearnData[];
  pendingDataLimitSeconds: number;
}

export interface CMsgSteamLearnSnapshotProjectResponse {
  snapshotResult: ESteamLearnSnapshotProjectResult;
}

export interface CMsgSteamLearnBatchOperationRequest {
  cacheDataRequests: CMsgSteamLearnCacheDataRequest[];
  snapshotRequests: CMsgSteamLearnSnapshotProjectRequest[];
}

export interface CMsgSteamLearnBatchOperationResponse {
  cacheDataResponses: CMsgSteamLearnCacheDataResponse[];
  snapshotResponses: CMsgSteamLearnSnapshotProjectResponse[];
}

export interface CMsgSteamLearnHMACKeys {
  registerDataSourceKey: string;
  cacheDataKeys: CMsgSteamLearnHMACKeys_CacheDataKeys[];
  snapshotProjectKeys: CMsgSteamLearnHMACKeys_SnapshotProjectKeys[];
}

export interface CMsgSteamLearnHMACKeys_CacheDataKeys {
  dataSourceId: number;
  version: number;
  key: string;
}

export interface CMsgSteamLearnHMACKeys_SnapshotProjectKeys {
  projectId: number;
  publishedVersion: number;
  key: string;
}

export interface CMsgSteamLearnGetHMACKeysRequest {
  appid: number;
}

export interface CMsgSteamLearnGetHMACKeysResponse {
  result: ESteamLearnGetHMACKeysResult;
  keys: CMsgSteamLearnHMACKeys | undefined;
}

export interface CMsgSteamLearnInferenceRequest {
  accessToken: string;
  accessData: CMsgSteamLearnAccessData | undefined;
  projectId: number;
  publishedVersion: number;
  overrideTrainId: number;
  data: CMsgSteamLearnDataList | undefined;
  additionalData: number[];
}

export interface CMsgSteamLearnInferenceMetadataRequest {
  accessToken: string;
  accessData: CMsgSteamLearnAccessData | undefined;
  projectId: number;
  publishedVersion: number;
  overrideTrainId: number;
}

export interface CMsgSteamLearnInferenceMetadataBackendRequest {
  projectId: number;
  fetchId: number;
}

export interface CMsgSteamLearnInferenceMetadataResponse {
  inferenceMetadataResult: ESteamLearnInferenceMetadataResult;
  rowRange: CMsgSteamLearnInferenceMetadataResponse_RowRange | undefined;
  ranges: CMsgSteamLearnInferenceMetadataResponse_Range[];
  stdDevs: CMsgSteamLearnInferenceMetadataResponse_StdDev[];
  compactTables: CMsgSteamLearnInferenceMetadataResponse_CompactTable[];
  kmeans: CMsgSteamLearnInferenceMetadataResponse_KMeans[];
  snapshotHistogram: CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram | undefined;
}

export interface CMsgSteamLearnInferenceMetadataResponse_RowRange {
  minRow: string;
  maxRow: string;
}

export interface CMsgSteamLearnInferenceMetadataResponse_Range {
  dataElementPath: string;
  minValue: number;
  maxValues: number;
}

export interface CMsgSteamLearnInferenceMetadataResponse_StdDev {
  dataElementPath: string;
  mean: number;
  stdDev: number;
}

export interface CMsgSteamLearnInferenceMetadataResponse_CompactTable {
  name: string;
  mapValues: CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry[];
  mapMappings: CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry[];
}

export interface CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry {
  value: number;
  mapping: number;
  count: string;
}

export interface CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry {
  key: number;
  value: CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry | undefined;
}

export interface CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry {
  key: number;
  value: CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry | undefined;
}

export interface CMsgSteamLearnInferenceMetadataResponse_KMeans {
  name: string;
  clusters: CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster[];
}

export interface CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster {
  x: number;
  y: number;
  radius: number;
  radius80pct: number;
}

export interface CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram {
  minValue: number;
  maxValue: number;
  numBuckets: number;
  bucketCounts: number[];
}

export interface CMsgSteamLearnInferenceBackendResponse {
  outputs: CMsgSteamLearnInferenceBackendResponse_Output[];
}

export interface CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput {
  value: number;
}

export interface CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput {
  weight: number[];
  value: number[];
}

export interface CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput {
  weight: number[];
  value: number[];
}

export interface CMsgSteamLearnInferenceBackendResponse_Output {
  binaryCrossentropy?: CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput | undefined;
  categoricalCrossentropy?: CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput | undefined;
  multiBinaryCrossentropy?: CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput | undefined;
}

export interface CMsgSteamLearnInferenceResponse {
  inferenceResult: ESteamLearnInferenceResult;
  backendResponse: CMsgSteamLearnInferenceBackendResponse | undefined;
}

function createBaseCMsgSteamLearnDataSourceDescObject(): CMsgSteamLearnDataSourceDescObject {
  return { elements: [] };
}

export const CMsgSteamLearnDataSourceDescObject: MessageFns<CMsgSteamLearnDataSourceDescObject> = {
  encode(message: CMsgSteamLearnDataSourceDescObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.elements) {
      CMsgSteamLearnDataSourceDescElement.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnDataSourceDescObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnDataSourceDescObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.elements.push(CMsgSteamLearnDataSourceDescElement.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnDataSourceDescObject {
    return {
      elements: globalThis.Array.isArray(object?.elements)
        ? object.elements.map((e: any) => CMsgSteamLearnDataSourceDescElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnDataSourceDescObject): unknown {
    const obj: any = {};
    if (message.elements?.length) {
      obj.elements = message.elements.map((e) => CMsgSteamLearnDataSourceDescElement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnDataSourceDescObject>): CMsgSteamLearnDataSourceDescObject {
    return CMsgSteamLearnDataSourceDescObject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnDataSourceDescObject>): CMsgSteamLearnDataSourceDescObject {
    const message = createBaseCMsgSteamLearnDataSourceDescObject();
    message.elements = object.elements?.map((e) => CMsgSteamLearnDataSourceDescElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnDataSourceDescElement(): CMsgSteamLearnDataSourceDescElement {
  return { name: "", dataType: 0, object: undefined, count: 0 };
}

export const CMsgSteamLearnDataSourceDescElement: MessageFns<CMsgSteamLearnDataSourceDescElement> = {
  encode(message: CMsgSteamLearnDataSourceDescElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataType !== 0) {
      writer.uint32(16).int32(message.dataType);
    }
    if (message.object !== undefined) {
      CMsgSteamLearnDataSourceDescObject.encode(message.object, writer.uint32(26).fork()).join();
    }
    if (message.count !== 0) {
      writer.uint32(32).uint32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnDataSourceDescElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnDataSourceDescElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.object = CMsgSteamLearnDataSourceDescObject.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnDataSourceDescElement {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataType: isSet(object.dataType) ? eSteamLearnDataTypeFromJSON(object.dataType) : 0,
      object: isSet(object.object) ? CMsgSteamLearnDataSourceDescObject.fromJSON(object.object) : undefined,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnDataSourceDescElement): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataType !== 0) {
      obj.dataType = eSteamLearnDataTypeToJSON(message.dataType);
    }
    if (message.object !== undefined) {
      obj.object = CMsgSteamLearnDataSourceDescObject.toJSON(message.object);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnDataSourceDescElement>): CMsgSteamLearnDataSourceDescElement {
    return CMsgSteamLearnDataSourceDescElement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnDataSourceDescElement>): CMsgSteamLearnDataSourceDescElement {
    const message = createBaseCMsgSteamLearnDataSourceDescElement();
    message.name = object.name ?? "";
    message.dataType = object.dataType ?? 0;
    message.object = (object.object !== undefined && object.object !== null)
      ? CMsgSteamLearnDataSourceDescObject.fromPartial(object.object)
      : undefined;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnDataSource(): CMsgSteamLearnDataSource {
  return {
    id: 0,
    name: "",
    version: 0,
    sourceDescription: "",
    structure: undefined,
    structureCrc: 0,
    cacheDurationSeconds: 0,
  };
}

export const CMsgSteamLearnDataSource: MessageFns<CMsgSteamLearnDataSource> = {
  encode(message: CMsgSteamLearnDataSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.version !== 0) {
      writer.uint32(24).uint32(message.version);
    }
    if (message.sourceDescription !== "") {
      writer.uint32(34).string(message.sourceDescription);
    }
    if (message.structure !== undefined) {
      CMsgSteamLearnDataSourceDescObject.encode(message.structure, writer.uint32(42).fork()).join();
    }
    if (message.structureCrc !== 0) {
      writer.uint32(48).uint32(message.structureCrc);
    }
    if (message.cacheDurationSeconds !== 0) {
      writer.uint32(56).uint32(message.cacheDurationSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnDataSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnDataSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sourceDescription = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.structure = CMsgSteamLearnDataSourceDescObject.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.structureCrc = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.cacheDurationSeconds = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnDataSource {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      sourceDescription: isSet(object.sourceDescription) ? globalThis.String(object.sourceDescription) : "",
      structure: isSet(object.structure) ? CMsgSteamLearnDataSourceDescObject.fromJSON(object.structure) : undefined,
      structureCrc: isSet(object.structureCrc) ? globalThis.Number(object.structureCrc) : 0,
      cacheDurationSeconds: isSet(object.cacheDurationSeconds) ? globalThis.Number(object.cacheDurationSeconds) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnDataSource): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.sourceDescription !== "") {
      obj.sourceDescription = message.sourceDescription;
    }
    if (message.structure !== undefined) {
      obj.structure = CMsgSteamLearnDataSourceDescObject.toJSON(message.structure);
    }
    if (message.structureCrc !== 0) {
      obj.structureCrc = Math.round(message.structureCrc);
    }
    if (message.cacheDurationSeconds !== 0) {
      obj.cacheDurationSeconds = Math.round(message.cacheDurationSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnDataSource>): CMsgSteamLearnDataSource {
    return CMsgSteamLearnDataSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnDataSource>): CMsgSteamLearnDataSource {
    const message = createBaseCMsgSteamLearnDataSource();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.version = object.version ?? 0;
    message.sourceDescription = object.sourceDescription ?? "";
    message.structure = (object.structure !== undefined && object.structure !== null)
      ? CMsgSteamLearnDataSourceDescObject.fromPartial(object.structure)
      : undefined;
    message.structureCrc = object.structureCrc ?? 0;
    message.cacheDurationSeconds = object.cacheDurationSeconds ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnDataObject(): CMsgSteamLearnDataObject {
  return { elements: [] };
}

export const CMsgSteamLearnDataObject: MessageFns<CMsgSteamLearnDataObject> = {
  encode(message: CMsgSteamLearnDataObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.elements) {
      CMsgSteamLearnDataElement.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnDataObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnDataObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.elements.push(CMsgSteamLearnDataElement.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnDataObject {
    return {
      elements: globalThis.Array.isArray(object?.elements)
        ? object.elements.map((e: any) => CMsgSteamLearnDataElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnDataObject): unknown {
    const obj: any = {};
    if (message.elements?.length) {
      obj.elements = message.elements.map((e) => CMsgSteamLearnDataElement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnDataObject>): CMsgSteamLearnDataObject {
    return CMsgSteamLearnDataObject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnDataObject>): CMsgSteamLearnDataObject {
    const message = createBaseCMsgSteamLearnDataObject();
    message.elements = object.elements?.map((e) => CMsgSteamLearnDataElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnDataElement(): CMsgSteamLearnDataElement {
  return { name: "", dataInt32s: [], dataFloats: [], dataBools: [], dataStrings: [], dataObjects: [] };
}

export const CMsgSteamLearnDataElement: MessageFns<CMsgSteamLearnDataElement> = {
  encode(message: CMsgSteamLearnDataElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    writer.uint32(162).fork();
    for (const v of message.dataInt32s) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(170).fork();
    for (const v of message.dataFloats) {
      writer.float(v);
    }
    writer.join();
    writer.uint32(178).fork();
    for (const v of message.dataBools) {
      writer.bool(v);
    }
    writer.join();
    for (const v of message.dataStrings) {
      writer.uint32(186).string(v!);
    }
    for (const v of message.dataObjects) {
      CMsgSteamLearnDataObject.encode(v!, writer.uint32(194).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnDataElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnDataElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 20: {
          if (tag === 160) {
            message.dataInt32s.push(reader.int32());

            continue;
          }

          if (tag === 162) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dataInt32s.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 21: {
          if (tag === 173) {
            message.dataFloats.push(reader.float());

            continue;
          }

          if (tag === 170) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dataFloats.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 22: {
          if (tag === 176) {
            message.dataBools.push(reader.bool());

            continue;
          }

          if (tag === 178) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dataBools.push(reader.bool());
            }

            continue;
          }

          break;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.dataStrings.push(reader.string());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.dataObjects.push(CMsgSteamLearnDataObject.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnDataElement {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataInt32s: globalThis.Array.isArray(object?.dataInt32s)
        ? object.dataInt32s.map((e: any) => globalThis.Number(e))
        : [],
      dataFloats: globalThis.Array.isArray(object?.dataFloats)
        ? object.dataFloats.map((e: any) => globalThis.Number(e))
        : [],
      dataBools: globalThis.Array.isArray(object?.dataBools)
        ? object.dataBools.map((e: any) => globalThis.Boolean(e))
        : [],
      dataStrings: globalThis.Array.isArray(object?.dataStrings)
        ? object.dataStrings.map((e: any) => globalThis.String(e))
        : [],
      dataObjects: globalThis.Array.isArray(object?.dataObjects)
        ? object.dataObjects.map((e: any) => CMsgSteamLearnDataObject.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnDataElement): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataInt32s?.length) {
      obj.dataInt32s = message.dataInt32s.map((e) => Math.round(e));
    }
    if (message.dataFloats?.length) {
      obj.dataFloats = message.dataFloats;
    }
    if (message.dataBools?.length) {
      obj.dataBools = message.dataBools;
    }
    if (message.dataStrings?.length) {
      obj.dataStrings = message.dataStrings;
    }
    if (message.dataObjects?.length) {
      obj.dataObjects = message.dataObjects.map((e) => CMsgSteamLearnDataObject.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnDataElement>): CMsgSteamLearnDataElement {
    return CMsgSteamLearnDataElement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnDataElement>): CMsgSteamLearnDataElement {
    const message = createBaseCMsgSteamLearnDataElement();
    message.name = object.name ?? "";
    message.dataInt32s = object.dataInt32s?.map((e) => e) || [];
    message.dataFloats = object.dataFloats?.map((e) => e) || [];
    message.dataBools = object.dataBools?.map((e) => e) || [];
    message.dataStrings = object.dataStrings?.map((e) => e) || [];
    message.dataObjects = object.dataObjects?.map((e) => CMsgSteamLearnDataObject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnData(): CMsgSteamLearnData {
  return { dataSourceId: 0, keys: [], dataObject: undefined };
}

export const CMsgSteamLearnData: MessageFns<CMsgSteamLearnData> = {
  encode(message: CMsgSteamLearnData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataSourceId !== 0) {
      writer.uint32(8).uint32(message.dataSourceId);
    }
    writer.uint32(18).fork();
    for (const v of message.keys) {
      writer.uint64(v);
    }
    writer.join();
    if (message.dataObject !== undefined) {
      CMsgSteamLearnDataObject.encode(message.dataObject, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dataSourceId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.keys.push(reader.uint64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.keys.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dataObject = CMsgSteamLearnDataObject.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnData {
    return {
      dataSourceId: isSet(object.dataSourceId) ? globalThis.Number(object.dataSourceId) : 0,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => globalThis.String(e)) : [],
      dataObject: isSet(object.dataObject) ? CMsgSteamLearnDataObject.fromJSON(object.dataObject) : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnData): unknown {
    const obj: any = {};
    if (message.dataSourceId !== 0) {
      obj.dataSourceId = Math.round(message.dataSourceId);
    }
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    if (message.dataObject !== undefined) {
      obj.dataObject = CMsgSteamLearnDataObject.toJSON(message.dataObject);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnData>): CMsgSteamLearnData {
    return CMsgSteamLearnData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnData>): CMsgSteamLearnData {
    const message = createBaseCMsgSteamLearnData();
    message.dataSourceId = object.dataSourceId ?? 0;
    message.keys = object.keys?.map((e) => e) || [];
    message.dataObject = (object.dataObject !== undefined && object.dataObject !== null)
      ? CMsgSteamLearnDataObject.fromPartial(object.dataObject)
      : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnDataList(): CMsgSteamLearnDataList {
  return { data: [] };
}

export const CMsgSteamLearnDataList: MessageFns<CMsgSteamLearnDataList> = {
  encode(message: CMsgSteamLearnDataList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.data) {
      CMsgSteamLearnData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnDataList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnDataList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data.push(CMsgSteamLearnData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnDataList {
    return {
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => CMsgSteamLearnData.fromJSON(e)) : [],
    };
  },

  toJSON(message: CMsgSteamLearnDataList): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => CMsgSteamLearnData.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnDataList>): CMsgSteamLearnDataList {
    return CMsgSteamLearnDataList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnDataList>): CMsgSteamLearnDataList {
    const message = createBaseCMsgSteamLearnDataList();
    message.data = object.data?.map((e) => CMsgSteamLearnData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnAccessData(): CMsgSteamLearnAccessData {
  return { publisherId: 0, timestamp: 0, randomValue: "0" };
}

export const CMsgSteamLearnAccessData: MessageFns<CMsgSteamLearnAccessData> = {
  encode(message: CMsgSteamLearnAccessData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publisherId !== 0) {
      writer.uint32(8).uint32(message.publisherId);
    }
    if (message.timestamp !== 0) {
      writer.uint32(16).uint32(message.timestamp);
    }
    if (message.randomValue !== "0") {
      writer.uint32(24).uint64(message.randomValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnAccessData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnAccessData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.publisherId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.randomValue = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnAccessData {
    return {
      publisherId: isSet(object.publisherId) ? globalThis.Number(object.publisherId) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      randomValue: isSet(object.randomValue) ? globalThis.String(object.randomValue) : "0",
    };
  },

  toJSON(message: CMsgSteamLearnAccessData): unknown {
    const obj: any = {};
    if (message.publisherId !== 0) {
      obj.publisherId = Math.round(message.publisherId);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.randomValue !== "0") {
      obj.randomValue = message.randomValue;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnAccessData>): CMsgSteamLearnAccessData {
    return CMsgSteamLearnAccessData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnAccessData>): CMsgSteamLearnAccessData {
    const message = createBaseCMsgSteamLearnAccessData();
    message.publisherId = object.publisherId ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.randomValue = object.randomValue ?? "0";
    return message;
  },
};

function createBaseCMsgSteamLearnRegisterDataSourceRequest(): CMsgSteamLearnRegisterDataSourceRequest {
  return { accessToken: "", accessData: undefined, dataSource: undefined };
}

export const CMsgSteamLearnRegisterDataSourceRequest: MessageFns<CMsgSteamLearnRegisterDataSourceRequest> = {
  encode(message: CMsgSteamLearnRegisterDataSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.accessData !== undefined) {
      CMsgSteamLearnAccessData.encode(message.accessData, writer.uint32(18).fork()).join();
    }
    if (message.dataSource !== undefined) {
      CMsgSteamLearnDataSource.encode(message.dataSource, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnRegisterDataSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnRegisterDataSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessData = CMsgSteamLearnAccessData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dataSource = CMsgSteamLearnDataSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnRegisterDataSourceRequest {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      accessData: isSet(object.accessData) ? CMsgSteamLearnAccessData.fromJSON(object.accessData) : undefined,
      dataSource: isSet(object.dataSource) ? CMsgSteamLearnDataSource.fromJSON(object.dataSource) : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnRegisterDataSourceRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.accessData !== undefined) {
      obj.accessData = CMsgSteamLearnAccessData.toJSON(message.accessData);
    }
    if (message.dataSource !== undefined) {
      obj.dataSource = CMsgSteamLearnDataSource.toJSON(message.dataSource);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnRegisterDataSourceRequest>): CMsgSteamLearnRegisterDataSourceRequest {
    return CMsgSteamLearnRegisterDataSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnRegisterDataSourceRequest>): CMsgSteamLearnRegisterDataSourceRequest {
    const message = createBaseCMsgSteamLearnRegisterDataSourceRequest();
    message.accessToken = object.accessToken ?? "";
    message.accessData = (object.accessData !== undefined && object.accessData !== null)
      ? CMsgSteamLearnAccessData.fromPartial(object.accessData)
      : undefined;
    message.dataSource = (object.dataSource !== undefined && object.dataSource !== null)
      ? CMsgSteamLearnDataSource.fromPartial(object.dataSource)
      : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnRegisterDataSourceResponse(): CMsgSteamLearnRegisterDataSourceResponse {
  return { result: 0, dataSource: undefined };
}

export const CMsgSteamLearnRegisterDataSourceResponse: MessageFns<CMsgSteamLearnRegisterDataSourceResponse> = {
  encode(message: CMsgSteamLearnRegisterDataSourceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.dataSource !== undefined) {
      CMsgSteamLearnDataSource.encode(message.dataSource, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnRegisterDataSourceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnRegisterDataSourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataSource = CMsgSteamLearnDataSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnRegisterDataSourceResponse {
    return {
      result: isSet(object.result) ? eSteammLearnRegisterDataSourceResultFromJSON(object.result) : 0,
      dataSource: isSet(object.dataSource) ? CMsgSteamLearnDataSource.fromJSON(object.dataSource) : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnRegisterDataSourceResponse): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = eSteammLearnRegisterDataSourceResultToJSON(message.result);
    }
    if (message.dataSource !== undefined) {
      obj.dataSource = CMsgSteamLearnDataSource.toJSON(message.dataSource);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnRegisterDataSourceResponse>): CMsgSteamLearnRegisterDataSourceResponse {
    return CMsgSteamLearnRegisterDataSourceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnRegisterDataSourceResponse>): CMsgSteamLearnRegisterDataSourceResponse {
    const message = createBaseCMsgSteamLearnRegisterDataSourceResponse();
    message.result = object.result ?? 0;
    message.dataSource = (object.dataSource !== undefined && object.dataSource !== null)
      ? CMsgSteamLearnDataSource.fromPartial(object.dataSource)
      : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnCacheDataRequest(): CMsgSteamLearnCacheDataRequest {
  return { accessToken: "", accessData: undefined, data: undefined };
}

export const CMsgSteamLearnCacheDataRequest: MessageFns<CMsgSteamLearnCacheDataRequest> = {
  encode(message: CMsgSteamLearnCacheDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.accessData !== undefined) {
      CMsgSteamLearnAccessData.encode(message.accessData, writer.uint32(18).fork()).join();
    }
    if (message.data !== undefined) {
      CMsgSteamLearnData.encode(message.data, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnCacheDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnCacheDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessData = CMsgSteamLearnAccessData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = CMsgSteamLearnData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnCacheDataRequest {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      accessData: isSet(object.accessData) ? CMsgSteamLearnAccessData.fromJSON(object.accessData) : undefined,
      data: isSet(object.data) ? CMsgSteamLearnData.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnCacheDataRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.accessData !== undefined) {
      obj.accessData = CMsgSteamLearnAccessData.toJSON(message.accessData);
    }
    if (message.data !== undefined) {
      obj.data = CMsgSteamLearnData.toJSON(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnCacheDataRequest>): CMsgSteamLearnCacheDataRequest {
    return CMsgSteamLearnCacheDataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnCacheDataRequest>): CMsgSteamLearnCacheDataRequest {
    const message = createBaseCMsgSteamLearnCacheDataRequest();
    message.accessToken = object.accessToken ?? "";
    message.accessData = (object.accessData !== undefined && object.accessData !== null)
      ? CMsgSteamLearnAccessData.fromPartial(object.accessData)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? CMsgSteamLearnData.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnCacheDataResponse(): CMsgSteamLearnCacheDataResponse {
  return { cacheDataResult: 0 };
}

export const CMsgSteamLearnCacheDataResponse: MessageFns<CMsgSteamLearnCacheDataResponse> = {
  encode(message: CMsgSteamLearnCacheDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cacheDataResult !== 0) {
      writer.uint32(8).int32(message.cacheDataResult);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnCacheDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnCacheDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cacheDataResult = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnCacheDataResponse {
    return {
      cacheDataResult: isSet(object.cacheDataResult) ? eSteamLearnCacheDataResultFromJSON(object.cacheDataResult) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnCacheDataResponse): unknown {
    const obj: any = {};
    if (message.cacheDataResult !== 0) {
      obj.cacheDataResult = eSteamLearnCacheDataResultToJSON(message.cacheDataResult);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnCacheDataResponse>): CMsgSteamLearnCacheDataResponse {
    return CMsgSteamLearnCacheDataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnCacheDataResponse>): CMsgSteamLearnCacheDataResponse {
    const message = createBaseCMsgSteamLearnCacheDataResponse();
    message.cacheDataResult = object.cacheDataResult ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnSnapshotProjectRequest(): CMsgSteamLearnSnapshotProjectRequest {
  return {
    accessToken: "",
    accessData: undefined,
    projectId: 0,
    publishedVersion: 0,
    keys: [],
    data: [],
    pendingDataLimitSeconds: 0,
  };
}

export const CMsgSteamLearnSnapshotProjectRequest: MessageFns<CMsgSteamLearnSnapshotProjectRequest> = {
  encode(message: CMsgSteamLearnSnapshotProjectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.accessData !== undefined) {
      CMsgSteamLearnAccessData.encode(message.accessData, writer.uint32(18).fork()).join();
    }
    if (message.projectId !== 0) {
      writer.uint32(24).uint32(message.projectId);
    }
    if (message.publishedVersion !== 0) {
      writer.uint32(56).uint32(message.publishedVersion);
    }
    writer.uint32(34).fork();
    for (const v of message.keys) {
      writer.uint64(v);
    }
    writer.join();
    for (const v of message.data) {
      CMsgSteamLearnData.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.pendingDataLimitSeconds !== 0) {
      writer.uint32(48).uint32(message.pendingDataLimitSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnSnapshotProjectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnSnapshotProjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessData = CMsgSteamLearnAccessData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.projectId = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.publishedVersion = reader.uint32();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.keys.push(reader.uint64().toString());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.keys.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.data.push(CMsgSteamLearnData.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.pendingDataLimitSeconds = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnSnapshotProjectRequest {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      accessData: isSet(object.accessData) ? CMsgSteamLearnAccessData.fromJSON(object.accessData) : undefined,
      projectId: isSet(object.projectId) ? globalThis.Number(object.projectId) : 0,
      publishedVersion: isSet(object.publishedVersion) ? globalThis.Number(object.publishedVersion) : 0,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => globalThis.String(e)) : [],
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => CMsgSteamLearnData.fromJSON(e)) : [],
      pendingDataLimitSeconds: isSet(object.pendingDataLimitSeconds)
        ? globalThis.Number(object.pendingDataLimitSeconds)
        : 0,
    };
  },

  toJSON(message: CMsgSteamLearnSnapshotProjectRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.accessData !== undefined) {
      obj.accessData = CMsgSteamLearnAccessData.toJSON(message.accessData);
    }
    if (message.projectId !== 0) {
      obj.projectId = Math.round(message.projectId);
    }
    if (message.publishedVersion !== 0) {
      obj.publishedVersion = Math.round(message.publishedVersion);
    }
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => CMsgSteamLearnData.toJSON(e));
    }
    if (message.pendingDataLimitSeconds !== 0) {
      obj.pendingDataLimitSeconds = Math.round(message.pendingDataLimitSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnSnapshotProjectRequest>): CMsgSteamLearnSnapshotProjectRequest {
    return CMsgSteamLearnSnapshotProjectRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnSnapshotProjectRequest>): CMsgSteamLearnSnapshotProjectRequest {
    const message = createBaseCMsgSteamLearnSnapshotProjectRequest();
    message.accessToken = object.accessToken ?? "";
    message.accessData = (object.accessData !== undefined && object.accessData !== null)
      ? CMsgSteamLearnAccessData.fromPartial(object.accessData)
      : undefined;
    message.projectId = object.projectId ?? 0;
    message.publishedVersion = object.publishedVersion ?? 0;
    message.keys = object.keys?.map((e) => e) || [];
    message.data = object.data?.map((e) => CMsgSteamLearnData.fromPartial(e)) || [];
    message.pendingDataLimitSeconds = object.pendingDataLimitSeconds ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnSnapshotProjectResponse(): CMsgSteamLearnSnapshotProjectResponse {
  return { snapshotResult: 0 };
}

export const CMsgSteamLearnSnapshotProjectResponse: MessageFns<CMsgSteamLearnSnapshotProjectResponse> = {
  encode(message: CMsgSteamLearnSnapshotProjectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.snapshotResult !== 0) {
      writer.uint32(8).int32(message.snapshotResult);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnSnapshotProjectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnSnapshotProjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.snapshotResult = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnSnapshotProjectResponse {
    return {
      snapshotResult: isSet(object.snapshotResult)
        ? eSteamLearnSnapshotProjectResultFromJSON(object.snapshotResult)
        : 0,
    };
  },

  toJSON(message: CMsgSteamLearnSnapshotProjectResponse): unknown {
    const obj: any = {};
    if (message.snapshotResult !== 0) {
      obj.snapshotResult = eSteamLearnSnapshotProjectResultToJSON(message.snapshotResult);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnSnapshotProjectResponse>): CMsgSteamLearnSnapshotProjectResponse {
    return CMsgSteamLearnSnapshotProjectResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnSnapshotProjectResponse>): CMsgSteamLearnSnapshotProjectResponse {
    const message = createBaseCMsgSteamLearnSnapshotProjectResponse();
    message.snapshotResult = object.snapshotResult ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnBatchOperationRequest(): CMsgSteamLearnBatchOperationRequest {
  return { cacheDataRequests: [], snapshotRequests: [] };
}

export const CMsgSteamLearnBatchOperationRequest: MessageFns<CMsgSteamLearnBatchOperationRequest> = {
  encode(message: CMsgSteamLearnBatchOperationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cacheDataRequests) {
      CMsgSteamLearnCacheDataRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.snapshotRequests) {
      CMsgSteamLearnSnapshotProjectRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnBatchOperationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnBatchOperationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cacheDataRequests.push(CMsgSteamLearnCacheDataRequest.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.snapshotRequests.push(CMsgSteamLearnSnapshotProjectRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnBatchOperationRequest {
    return {
      cacheDataRequests: globalThis.Array.isArray(object?.cacheDataRequests)
        ? object.cacheDataRequests.map((e: any) => CMsgSteamLearnCacheDataRequest.fromJSON(e))
        : [],
      snapshotRequests: globalThis.Array.isArray(object?.snapshotRequests)
        ? object.snapshotRequests.map((e: any) => CMsgSteamLearnSnapshotProjectRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnBatchOperationRequest): unknown {
    const obj: any = {};
    if (message.cacheDataRequests?.length) {
      obj.cacheDataRequests = message.cacheDataRequests.map((e) => CMsgSteamLearnCacheDataRequest.toJSON(e));
    }
    if (message.snapshotRequests?.length) {
      obj.snapshotRequests = message.snapshotRequests.map((e) => CMsgSteamLearnSnapshotProjectRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnBatchOperationRequest>): CMsgSteamLearnBatchOperationRequest {
    return CMsgSteamLearnBatchOperationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnBatchOperationRequest>): CMsgSteamLearnBatchOperationRequest {
    const message = createBaseCMsgSteamLearnBatchOperationRequest();
    message.cacheDataRequests = object.cacheDataRequests?.map((e) => CMsgSteamLearnCacheDataRequest.fromPartial(e)) ||
      [];
    message.snapshotRequests =
      object.snapshotRequests?.map((e) => CMsgSteamLearnSnapshotProjectRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnBatchOperationResponse(): CMsgSteamLearnBatchOperationResponse {
  return { cacheDataResponses: [], snapshotResponses: [] };
}

export const CMsgSteamLearnBatchOperationResponse: MessageFns<CMsgSteamLearnBatchOperationResponse> = {
  encode(message: CMsgSteamLearnBatchOperationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cacheDataResponses) {
      CMsgSteamLearnCacheDataResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.snapshotResponses) {
      CMsgSteamLearnSnapshotProjectResponse.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnBatchOperationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnBatchOperationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cacheDataResponses.push(CMsgSteamLearnCacheDataResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.snapshotResponses.push(CMsgSteamLearnSnapshotProjectResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnBatchOperationResponse {
    return {
      cacheDataResponses: globalThis.Array.isArray(object?.cacheDataResponses)
        ? object.cacheDataResponses.map((e: any) => CMsgSteamLearnCacheDataResponse.fromJSON(e))
        : [],
      snapshotResponses: globalThis.Array.isArray(object?.snapshotResponses)
        ? object.snapshotResponses.map((e: any) => CMsgSteamLearnSnapshotProjectResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnBatchOperationResponse): unknown {
    const obj: any = {};
    if (message.cacheDataResponses?.length) {
      obj.cacheDataResponses = message.cacheDataResponses.map((e) => CMsgSteamLearnCacheDataResponse.toJSON(e));
    }
    if (message.snapshotResponses?.length) {
      obj.snapshotResponses = message.snapshotResponses.map((e) => CMsgSteamLearnSnapshotProjectResponse.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnBatchOperationResponse>): CMsgSteamLearnBatchOperationResponse {
    return CMsgSteamLearnBatchOperationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnBatchOperationResponse>): CMsgSteamLearnBatchOperationResponse {
    const message = createBaseCMsgSteamLearnBatchOperationResponse();
    message.cacheDataResponses =
      object.cacheDataResponses?.map((e) => CMsgSteamLearnCacheDataResponse.fromPartial(e)) || [];
    message.snapshotResponses =
      object.snapshotResponses?.map((e) => CMsgSteamLearnSnapshotProjectResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnHMACKeys(): CMsgSteamLearnHMACKeys {
  return { registerDataSourceKey: "", cacheDataKeys: [], snapshotProjectKeys: [] };
}

export const CMsgSteamLearnHMACKeys: MessageFns<CMsgSteamLearnHMACKeys> = {
  encode(message: CMsgSteamLearnHMACKeys, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.registerDataSourceKey !== "") {
      writer.uint32(10).string(message.registerDataSourceKey);
    }
    for (const v of message.cacheDataKeys) {
      CMsgSteamLearnHMACKeys_CacheDataKeys.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.snapshotProjectKeys) {
      CMsgSteamLearnHMACKeys_SnapshotProjectKeys.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnHMACKeys {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnHMACKeys();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.registerDataSourceKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cacheDataKeys.push(CMsgSteamLearnHMACKeys_CacheDataKeys.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.snapshotProjectKeys.push(CMsgSteamLearnHMACKeys_SnapshotProjectKeys.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnHMACKeys {
    return {
      registerDataSourceKey: isSet(object.registerDataSourceKey) ? globalThis.String(object.registerDataSourceKey) : "",
      cacheDataKeys: globalThis.Array.isArray(object?.cacheDataKeys)
        ? object.cacheDataKeys.map((e: any) => CMsgSteamLearnHMACKeys_CacheDataKeys.fromJSON(e))
        : [],
      snapshotProjectKeys: globalThis.Array.isArray(object?.snapshotProjectKeys)
        ? object.snapshotProjectKeys.map((e: any) => CMsgSteamLearnHMACKeys_SnapshotProjectKeys.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnHMACKeys): unknown {
    const obj: any = {};
    if (message.registerDataSourceKey !== "") {
      obj.registerDataSourceKey = message.registerDataSourceKey;
    }
    if (message.cacheDataKeys?.length) {
      obj.cacheDataKeys = message.cacheDataKeys.map((e) => CMsgSteamLearnHMACKeys_CacheDataKeys.toJSON(e));
    }
    if (message.snapshotProjectKeys?.length) {
      obj.snapshotProjectKeys = message.snapshotProjectKeys.map((e) =>
        CMsgSteamLearnHMACKeys_SnapshotProjectKeys.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnHMACKeys>): CMsgSteamLearnHMACKeys {
    return CMsgSteamLearnHMACKeys.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnHMACKeys>): CMsgSteamLearnHMACKeys {
    const message = createBaseCMsgSteamLearnHMACKeys();
    message.registerDataSourceKey = object.registerDataSourceKey ?? "";
    message.cacheDataKeys = object.cacheDataKeys?.map((e) => CMsgSteamLearnHMACKeys_CacheDataKeys.fromPartial(e)) || [];
    message.snapshotProjectKeys =
      object.snapshotProjectKeys?.map((e) => CMsgSteamLearnHMACKeys_SnapshotProjectKeys.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnHMACKeys_CacheDataKeys(): CMsgSteamLearnHMACKeys_CacheDataKeys {
  return { dataSourceId: 0, version: 0, key: "" };
}

export const CMsgSteamLearnHMACKeys_CacheDataKeys: MessageFns<CMsgSteamLearnHMACKeys_CacheDataKeys> = {
  encode(message: CMsgSteamLearnHMACKeys_CacheDataKeys, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataSourceId !== 0) {
      writer.uint32(8).uint32(message.dataSourceId);
    }
    if (message.version !== 0) {
      writer.uint32(24).uint32(message.version);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnHMACKeys_CacheDataKeys {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnHMACKeys_CacheDataKeys();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dataSourceId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnHMACKeys_CacheDataKeys {
    return {
      dataSourceId: isSet(object.dataSourceId) ? globalThis.Number(object.dataSourceId) : 0,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: CMsgSteamLearnHMACKeys_CacheDataKeys): unknown {
    const obj: any = {};
    if (message.dataSourceId !== 0) {
      obj.dataSourceId = Math.round(message.dataSourceId);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnHMACKeys_CacheDataKeys>): CMsgSteamLearnHMACKeys_CacheDataKeys {
    return CMsgSteamLearnHMACKeys_CacheDataKeys.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnHMACKeys_CacheDataKeys>): CMsgSteamLearnHMACKeys_CacheDataKeys {
    const message = createBaseCMsgSteamLearnHMACKeys_CacheDataKeys();
    message.dataSourceId = object.dataSourceId ?? 0;
    message.version = object.version ?? 0;
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseCMsgSteamLearnHMACKeys_SnapshotProjectKeys(): CMsgSteamLearnHMACKeys_SnapshotProjectKeys {
  return { projectId: 0, publishedVersion: 0, key: "" };
}

export const CMsgSteamLearnHMACKeys_SnapshotProjectKeys: MessageFns<CMsgSteamLearnHMACKeys_SnapshotProjectKeys> = {
  encode(message: CMsgSteamLearnHMACKeys_SnapshotProjectKeys, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== 0) {
      writer.uint32(8).uint32(message.projectId);
    }
    if (message.publishedVersion !== 0) {
      writer.uint32(24).uint32(message.publishedVersion);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnHMACKeys_SnapshotProjectKeys {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnHMACKeys_SnapshotProjectKeys();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.projectId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.publishedVersion = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnHMACKeys_SnapshotProjectKeys {
    return {
      projectId: isSet(object.projectId) ? globalThis.Number(object.projectId) : 0,
      publishedVersion: isSet(object.publishedVersion) ? globalThis.Number(object.publishedVersion) : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: CMsgSteamLearnHMACKeys_SnapshotProjectKeys): unknown {
    const obj: any = {};
    if (message.projectId !== 0) {
      obj.projectId = Math.round(message.projectId);
    }
    if (message.publishedVersion !== 0) {
      obj.publishedVersion = Math.round(message.publishedVersion);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnHMACKeys_SnapshotProjectKeys>): CMsgSteamLearnHMACKeys_SnapshotProjectKeys {
    return CMsgSteamLearnHMACKeys_SnapshotProjectKeys.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnHMACKeys_SnapshotProjectKeys>,
  ): CMsgSteamLearnHMACKeys_SnapshotProjectKeys {
    const message = createBaseCMsgSteamLearnHMACKeys_SnapshotProjectKeys();
    message.projectId = object.projectId ?? 0;
    message.publishedVersion = object.publishedVersion ?? 0;
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseCMsgSteamLearnGetHMACKeysRequest(): CMsgSteamLearnGetHMACKeysRequest {
  return { appid: 0 };
}

export const CMsgSteamLearnGetHMACKeysRequest: MessageFns<CMsgSteamLearnGetHMACKeysRequest> = {
  encode(message: CMsgSteamLearnGetHMACKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appid !== 0) {
      writer.uint32(8).uint32(message.appid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnGetHMACKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnGetHMACKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnGetHMACKeysRequest {
    return { appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0 };
  },

  toJSON(message: CMsgSteamLearnGetHMACKeysRequest): unknown {
    const obj: any = {};
    if (message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnGetHMACKeysRequest>): CMsgSteamLearnGetHMACKeysRequest {
    return CMsgSteamLearnGetHMACKeysRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnGetHMACKeysRequest>): CMsgSteamLearnGetHMACKeysRequest {
    const message = createBaseCMsgSteamLearnGetHMACKeysRequest();
    message.appid = object.appid ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnGetHMACKeysResponse(): CMsgSteamLearnGetHMACKeysResponse {
  return { result: 0, keys: undefined };
}

export const CMsgSteamLearnGetHMACKeysResponse: MessageFns<CMsgSteamLearnGetHMACKeysResponse> = {
  encode(message: CMsgSteamLearnGetHMACKeysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.keys !== undefined) {
      CMsgSteamLearnHMACKeys.encode(message.keys, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnGetHMACKeysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnGetHMACKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keys = CMsgSteamLearnHMACKeys.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnGetHMACKeysResponse {
    return {
      result: isSet(object.result) ? eSteamLearnGetHMACKeysResultFromJSON(object.result) : 0,
      keys: isSet(object.keys) ? CMsgSteamLearnHMACKeys.fromJSON(object.keys) : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnGetHMACKeysResponse): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = eSteamLearnGetHMACKeysResultToJSON(message.result);
    }
    if (message.keys !== undefined) {
      obj.keys = CMsgSteamLearnHMACKeys.toJSON(message.keys);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnGetHMACKeysResponse>): CMsgSteamLearnGetHMACKeysResponse {
    return CMsgSteamLearnGetHMACKeysResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnGetHMACKeysResponse>): CMsgSteamLearnGetHMACKeysResponse {
    const message = createBaseCMsgSteamLearnGetHMACKeysResponse();
    message.result = object.result ?? 0;
    message.keys = (object.keys !== undefined && object.keys !== null)
      ? CMsgSteamLearnHMACKeys.fromPartial(object.keys)
      : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceRequest(): CMsgSteamLearnInferenceRequest {
  return {
    accessToken: "",
    accessData: undefined,
    projectId: 0,
    publishedVersion: 0,
    overrideTrainId: 0,
    data: undefined,
    additionalData: [],
  };
}

export const CMsgSteamLearnInferenceRequest: MessageFns<CMsgSteamLearnInferenceRequest> = {
  encode(message: CMsgSteamLearnInferenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.accessData !== undefined) {
      CMsgSteamLearnAccessData.encode(message.accessData, writer.uint32(18).fork()).join();
    }
    if (message.projectId !== 0) {
      writer.uint32(24).uint32(message.projectId);
    }
    if (message.publishedVersion !== 0) {
      writer.uint32(32).uint32(message.publishedVersion);
    }
    if (message.overrideTrainId !== 0) {
      writer.uint32(40).uint32(message.overrideTrainId);
    }
    if (message.data !== undefined) {
      CMsgSteamLearnDataList.encode(message.data, writer.uint32(50).fork()).join();
    }
    writer.uint32(58).fork();
    for (const v of message.additionalData) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnInferenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessData = CMsgSteamLearnAccessData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.projectId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.publishedVersion = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.overrideTrainId = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.data = CMsgSteamLearnDataList.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag === 61) {
            message.additionalData.push(reader.float());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.additionalData.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceRequest {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      accessData: isSet(object.accessData) ? CMsgSteamLearnAccessData.fromJSON(object.accessData) : undefined,
      projectId: isSet(object.projectId) ? globalThis.Number(object.projectId) : 0,
      publishedVersion: isSet(object.publishedVersion) ? globalThis.Number(object.publishedVersion) : 0,
      overrideTrainId: isSet(object.overrideTrainId) ? globalThis.Number(object.overrideTrainId) : 0,
      data: isSet(object.data) ? CMsgSteamLearnDataList.fromJSON(object.data) : undefined,
      additionalData: globalThis.Array.isArray(object?.additionalData)
        ? object.additionalData.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnInferenceRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.accessData !== undefined) {
      obj.accessData = CMsgSteamLearnAccessData.toJSON(message.accessData);
    }
    if (message.projectId !== 0) {
      obj.projectId = Math.round(message.projectId);
    }
    if (message.publishedVersion !== 0) {
      obj.publishedVersion = Math.round(message.publishedVersion);
    }
    if (message.overrideTrainId !== 0) {
      obj.overrideTrainId = Math.round(message.overrideTrainId);
    }
    if (message.data !== undefined) {
      obj.data = CMsgSteamLearnDataList.toJSON(message.data);
    }
    if (message.additionalData?.length) {
      obj.additionalData = message.additionalData;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnInferenceRequest>): CMsgSteamLearnInferenceRequest {
    return CMsgSteamLearnInferenceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnInferenceRequest>): CMsgSteamLearnInferenceRequest {
    const message = createBaseCMsgSteamLearnInferenceRequest();
    message.accessToken = object.accessToken ?? "";
    message.accessData = (object.accessData !== undefined && object.accessData !== null)
      ? CMsgSteamLearnAccessData.fromPartial(object.accessData)
      : undefined;
    message.projectId = object.projectId ?? 0;
    message.publishedVersion = object.publishedVersion ?? 0;
    message.overrideTrainId = object.overrideTrainId ?? 0;
    message.data = (object.data !== undefined && object.data !== null)
      ? CMsgSteamLearnDataList.fromPartial(object.data)
      : undefined;
    message.additionalData = object.additionalData?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataRequest(): CMsgSteamLearnInferenceMetadataRequest {
  return { accessToken: "", accessData: undefined, projectId: 0, publishedVersion: 0, overrideTrainId: 0 };
}

export const CMsgSteamLearnInferenceMetadataRequest: MessageFns<CMsgSteamLearnInferenceMetadataRequest> = {
  encode(message: CMsgSteamLearnInferenceMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.accessData !== undefined) {
      CMsgSteamLearnAccessData.encode(message.accessData, writer.uint32(18).fork()).join();
    }
    if (message.projectId !== 0) {
      writer.uint32(24).uint32(message.projectId);
    }
    if (message.publishedVersion !== 0) {
      writer.uint32(32).uint32(message.publishedVersion);
    }
    if (message.overrideTrainId !== 0) {
      writer.uint32(40).uint32(message.overrideTrainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessData = CMsgSteamLearnAccessData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.projectId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.publishedVersion = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.overrideTrainId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataRequest {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      accessData: isSet(object.accessData) ? CMsgSteamLearnAccessData.fromJSON(object.accessData) : undefined,
      projectId: isSet(object.projectId) ? globalThis.Number(object.projectId) : 0,
      publishedVersion: isSet(object.publishedVersion) ? globalThis.Number(object.publishedVersion) : 0,
      overrideTrainId: isSet(object.overrideTrainId) ? globalThis.Number(object.overrideTrainId) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.accessData !== undefined) {
      obj.accessData = CMsgSteamLearnAccessData.toJSON(message.accessData);
    }
    if (message.projectId !== 0) {
      obj.projectId = Math.round(message.projectId);
    }
    if (message.publishedVersion !== 0) {
      obj.publishedVersion = Math.round(message.publishedVersion);
    }
    if (message.overrideTrainId !== 0) {
      obj.overrideTrainId = Math.round(message.overrideTrainId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnInferenceMetadataRequest>): CMsgSteamLearnInferenceMetadataRequest {
    return CMsgSteamLearnInferenceMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnInferenceMetadataRequest>): CMsgSteamLearnInferenceMetadataRequest {
    const message = createBaseCMsgSteamLearnInferenceMetadataRequest();
    message.accessToken = object.accessToken ?? "";
    message.accessData = (object.accessData !== undefined && object.accessData !== null)
      ? CMsgSteamLearnAccessData.fromPartial(object.accessData)
      : undefined;
    message.projectId = object.projectId ?? 0;
    message.publishedVersion = object.publishedVersion ?? 0;
    message.overrideTrainId = object.overrideTrainId ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataBackendRequest(): CMsgSteamLearnInferenceMetadataBackendRequest {
  return { projectId: 0, fetchId: 0 };
}

export const CMsgSteamLearnInferenceMetadataBackendRequest: MessageFns<CMsgSteamLearnInferenceMetadataBackendRequest> =
  {
    encode(
      message: CMsgSteamLearnInferenceMetadataBackendRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.projectId !== 0) {
        writer.uint32(8).uint32(message.projectId);
      }
      if (message.fetchId !== 0) {
        writer.uint32(16).uint32(message.fetchId);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataBackendRequest {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCMsgSteamLearnInferenceMetadataBackendRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.projectId = reader.uint32();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.fetchId = reader.uint32();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CMsgSteamLearnInferenceMetadataBackendRequest {
      return {
        projectId: isSet(object.projectId) ? globalThis.Number(object.projectId) : 0,
        fetchId: isSet(object.fetchId) ? globalThis.Number(object.fetchId) : 0,
      };
    },

    toJSON(message: CMsgSteamLearnInferenceMetadataBackendRequest): unknown {
      const obj: any = {};
      if (message.projectId !== 0) {
        obj.projectId = Math.round(message.projectId);
      }
      if (message.fetchId !== 0) {
        obj.fetchId = Math.round(message.fetchId);
      }
      return obj;
    },

    create(
      base?: DeepPartial<CMsgSteamLearnInferenceMetadataBackendRequest>,
    ): CMsgSteamLearnInferenceMetadataBackendRequest {
      return CMsgSteamLearnInferenceMetadataBackendRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<CMsgSteamLearnInferenceMetadataBackendRequest>,
    ): CMsgSteamLearnInferenceMetadataBackendRequest {
      const message = createBaseCMsgSteamLearnInferenceMetadataBackendRequest();
      message.projectId = object.projectId ?? 0;
      message.fetchId = object.fetchId ?? 0;
      return message;
    },
  };

function createBaseCMsgSteamLearnInferenceMetadataResponse(): CMsgSteamLearnInferenceMetadataResponse {
  return {
    inferenceMetadataResult: 0,
    rowRange: undefined,
    ranges: [],
    stdDevs: [],
    compactTables: [],
    kmeans: [],
    snapshotHistogram: undefined,
  };
}

export const CMsgSteamLearnInferenceMetadataResponse: MessageFns<CMsgSteamLearnInferenceMetadataResponse> = {
  encode(message: CMsgSteamLearnInferenceMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inferenceMetadataResult !== 0) {
      writer.uint32(8).int32(message.inferenceMetadataResult);
    }
    if (message.rowRange !== undefined) {
      CMsgSteamLearnInferenceMetadataResponse_RowRange.encode(message.rowRange, writer.uint32(18).fork()).join();
    }
    for (const v of message.ranges) {
      CMsgSteamLearnInferenceMetadataResponse_Range.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.stdDevs) {
      CMsgSteamLearnInferenceMetadataResponse_StdDev.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.compactTables) {
      CMsgSteamLearnInferenceMetadataResponse_CompactTable.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.kmeans) {
      CMsgSteamLearnInferenceMetadataResponse_KMeans.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.snapshotHistogram !== undefined) {
      CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram.encode(
        message.snapshotHistogram,
        writer.uint32(58).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.inferenceMetadataResult = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rowRange = CMsgSteamLearnInferenceMetadataResponse_RowRange.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ranges.push(CMsgSteamLearnInferenceMetadataResponse_Range.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stdDevs.push(CMsgSteamLearnInferenceMetadataResponse_StdDev.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.compactTables.push(
            CMsgSteamLearnInferenceMetadataResponse_CompactTable.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.kmeans.push(CMsgSteamLearnInferenceMetadataResponse_KMeans.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.snapshotHistogram = CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse {
    return {
      inferenceMetadataResult: isSet(object.inferenceMetadataResult)
        ? eSteamLearnInferenceMetadataResultFromJSON(object.inferenceMetadataResult)
        : 0,
      rowRange: isSet(object.rowRange)
        ? CMsgSteamLearnInferenceMetadataResponse_RowRange.fromJSON(object.rowRange)
        : undefined,
      ranges: globalThis.Array.isArray(object?.ranges)
        ? object.ranges.map((e: any) => CMsgSteamLearnInferenceMetadataResponse_Range.fromJSON(e))
        : [],
      stdDevs: globalThis.Array.isArray(object?.stdDevs)
        ? object.stdDevs.map((e: any) => CMsgSteamLearnInferenceMetadataResponse_StdDev.fromJSON(e))
        : [],
      compactTables: globalThis.Array.isArray(object?.compactTables)
        ? object.compactTables.map((e: any) => CMsgSteamLearnInferenceMetadataResponse_CompactTable.fromJSON(e))
        : [],
      kmeans: globalThis.Array.isArray(object?.kmeans)
        ? object.kmeans.map((e: any) => CMsgSteamLearnInferenceMetadataResponse_KMeans.fromJSON(e))
        : [],
      snapshotHistogram: isSet(object.snapshotHistogram)
        ? CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram.fromJSON(object.snapshotHistogram)
        : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse): unknown {
    const obj: any = {};
    if (message.inferenceMetadataResult !== 0) {
      obj.inferenceMetadataResult = eSteamLearnInferenceMetadataResultToJSON(message.inferenceMetadataResult);
    }
    if (message.rowRange !== undefined) {
      obj.rowRange = CMsgSteamLearnInferenceMetadataResponse_RowRange.toJSON(message.rowRange);
    }
    if (message.ranges?.length) {
      obj.ranges = message.ranges.map((e) => CMsgSteamLearnInferenceMetadataResponse_Range.toJSON(e));
    }
    if (message.stdDevs?.length) {
      obj.stdDevs = message.stdDevs.map((e) => CMsgSteamLearnInferenceMetadataResponse_StdDev.toJSON(e));
    }
    if (message.compactTables?.length) {
      obj.compactTables = message.compactTables.map((e) =>
        CMsgSteamLearnInferenceMetadataResponse_CompactTable.toJSON(e)
      );
    }
    if (message.kmeans?.length) {
      obj.kmeans = message.kmeans.map((e) => CMsgSteamLearnInferenceMetadataResponse_KMeans.toJSON(e));
    }
    if (message.snapshotHistogram !== undefined) {
      obj.snapshotHistogram = CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram.toJSON(
        message.snapshotHistogram,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse>): CMsgSteamLearnInferenceMetadataResponse {
    return CMsgSteamLearnInferenceMetadataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse>): CMsgSteamLearnInferenceMetadataResponse {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse();
    message.inferenceMetadataResult = object.inferenceMetadataResult ?? 0;
    message.rowRange = (object.rowRange !== undefined && object.rowRange !== null)
      ? CMsgSteamLearnInferenceMetadataResponse_RowRange.fromPartial(object.rowRange)
      : undefined;
    message.ranges = object.ranges?.map((e) => CMsgSteamLearnInferenceMetadataResponse_Range.fromPartial(e)) || [];
    message.stdDevs = object.stdDevs?.map((e) => CMsgSteamLearnInferenceMetadataResponse_StdDev.fromPartial(e)) || [];
    message.compactTables =
      object.compactTables?.map((e) => CMsgSteamLearnInferenceMetadataResponse_CompactTable.fromPartial(e)) || [];
    message.kmeans = object.kmeans?.map((e) => CMsgSteamLearnInferenceMetadataResponse_KMeans.fromPartial(e)) || [];
    message.snapshotHistogram = (object.snapshotHistogram !== undefined && object.snapshotHistogram !== null)
      ? CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram.fromPartial(object.snapshotHistogram)
      : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_RowRange(): CMsgSteamLearnInferenceMetadataResponse_RowRange {
  return { minRow: "0", maxRow: "0" };
}

export const CMsgSteamLearnInferenceMetadataResponse_RowRange: MessageFns<
  CMsgSteamLearnInferenceMetadataResponse_RowRange
> = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_RowRange,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.minRow !== "0") {
      writer.uint32(8).uint64(message.minRow);
    }
    if (message.maxRow !== "0") {
      writer.uint32(16).uint64(message.maxRow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse_RowRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_RowRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.minRow = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxRow = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_RowRange {
    return {
      minRow: isSet(object.minRow) ? globalThis.String(object.minRow) : "0",
      maxRow: isSet(object.maxRow) ? globalThis.String(object.maxRow) : "0",
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_RowRange): unknown {
    const obj: any = {};
    if (message.minRow !== "0") {
      obj.minRow = message.minRow;
    }
    if (message.maxRow !== "0") {
      obj.maxRow = message.maxRow;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_RowRange>,
  ): CMsgSteamLearnInferenceMetadataResponse_RowRange {
    return CMsgSteamLearnInferenceMetadataResponse_RowRange.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_RowRange>,
  ): CMsgSteamLearnInferenceMetadataResponse_RowRange {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_RowRange();
    message.minRow = object.minRow ?? "0";
    message.maxRow = object.maxRow ?? "0";
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_Range(): CMsgSteamLearnInferenceMetadataResponse_Range {
  return { dataElementPath: "", minValue: 0, maxValues: 0 };
}

export const CMsgSteamLearnInferenceMetadataResponse_Range: MessageFns<CMsgSteamLearnInferenceMetadataResponse_Range> =
  {
    encode(
      message: CMsgSteamLearnInferenceMetadataResponse_Range,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.dataElementPath !== "") {
        writer.uint32(10).string(message.dataElementPath);
      }
      if (message.minValue !== 0) {
        writer.uint32(16).int32(message.minValue);
      }
      if (message.maxValues !== 0) {
        writer.uint32(24).int32(message.maxValues);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse_Range {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCMsgSteamLearnInferenceMetadataResponse_Range();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.dataElementPath = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.minValue = reader.int32();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.maxValues = reader.int32();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_Range {
      return {
        dataElementPath: isSet(object.dataElementPath) ? globalThis.String(object.dataElementPath) : "",
        minValue: isSet(object.minValue) ? globalThis.Number(object.minValue) : 0,
        maxValues: isSet(object.maxValues) ? globalThis.Number(object.maxValues) : 0,
      };
    },

    toJSON(message: CMsgSteamLearnInferenceMetadataResponse_Range): unknown {
      const obj: any = {};
      if (message.dataElementPath !== "") {
        obj.dataElementPath = message.dataElementPath;
      }
      if (message.minValue !== 0) {
        obj.minValue = Math.round(message.minValue);
      }
      if (message.maxValues !== 0) {
        obj.maxValues = Math.round(message.maxValues);
      }
      return obj;
    },

    create(
      base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_Range>,
    ): CMsgSteamLearnInferenceMetadataResponse_Range {
      return CMsgSteamLearnInferenceMetadataResponse_Range.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_Range>,
    ): CMsgSteamLearnInferenceMetadataResponse_Range {
      const message = createBaseCMsgSteamLearnInferenceMetadataResponse_Range();
      message.dataElementPath = object.dataElementPath ?? "";
      message.minValue = object.minValue ?? 0;
      message.maxValues = object.maxValues ?? 0;
      return message;
    },
  };

function createBaseCMsgSteamLearnInferenceMetadataResponse_StdDev(): CMsgSteamLearnInferenceMetadataResponse_StdDev {
  return { dataElementPath: "", mean: 0, stdDev: 0 };
}

export const CMsgSteamLearnInferenceMetadataResponse_StdDev: MessageFns<
  CMsgSteamLearnInferenceMetadataResponse_StdDev
> = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_StdDev,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.dataElementPath !== "") {
      writer.uint32(10).string(message.dataElementPath);
    }
    if (message.mean !== 0) {
      writer.uint32(16).int32(message.mean);
    }
    if (message.stdDev !== 0) {
      writer.uint32(24).uint32(message.stdDev);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse_StdDev {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_StdDev();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dataElementPath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mean = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.stdDev = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_StdDev {
    return {
      dataElementPath: isSet(object.dataElementPath) ? globalThis.String(object.dataElementPath) : "",
      mean: isSet(object.mean) ? globalThis.Number(object.mean) : 0,
      stdDev: isSet(object.stdDev) ? globalThis.Number(object.stdDev) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_StdDev): unknown {
    const obj: any = {};
    if (message.dataElementPath !== "") {
      obj.dataElementPath = message.dataElementPath;
    }
    if (message.mean !== 0) {
      obj.mean = Math.round(message.mean);
    }
    if (message.stdDev !== 0) {
      obj.stdDev = Math.round(message.stdDev);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_StdDev>,
  ): CMsgSteamLearnInferenceMetadataResponse_StdDev {
    return CMsgSteamLearnInferenceMetadataResponse_StdDev.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_StdDev>,
  ): CMsgSteamLearnInferenceMetadataResponse_StdDev {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_StdDev();
    message.dataElementPath = object.dataElementPath ?? "";
    message.mean = object.mean ?? 0;
    message.stdDev = object.stdDev ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable(): CMsgSteamLearnInferenceMetadataResponse_CompactTable {
  return { name: "", mapValues: [], mapMappings: [] };
}

export const CMsgSteamLearnInferenceMetadataResponse_CompactTable: MessageFns<
  CMsgSteamLearnInferenceMetadataResponse_CompactTable
> = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_CompactTable,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.mapValues) {
      CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.mapMappings) {
      CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse_CompactTable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mapValues.push(
            CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mapMappings.push(
            CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_CompactTable {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      mapValues: globalThis.Array.isArray(object?.mapValues)
        ? object.mapValues.map((e: any) =>
          CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry.fromJSON(e)
        )
        : [],
      mapMappings: globalThis.Array.isArray(object?.mapMappings)
        ? object.mapMappings.map((e: any) =>
          CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_CompactTable): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.mapValues?.length) {
      obj.mapValues = message.mapValues.map((e) =>
        CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry.toJSON(e)
      );
    }
    if (message.mapMappings?.length) {
      obj.mapMappings = message.mapMappings.map((e) =>
        CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry.toJSON(e)
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable {
    return CMsgSteamLearnInferenceMetadataResponse_CompactTable.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable();
    message.name = object.name ?? "";
    message.mapValues =
      object.mapValues?.map((e) =>
        CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry.fromPartial(e)
      ) || [];
    message.mapMappings =
      object.mapMappings?.map((e) =>
        CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry(): CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry {
  return { value: 0, mapping: 0, count: "0" };
}

export const CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry: MessageFns<
  CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry
> = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).uint32(message.value);
    }
    if (message.mapping !== 0) {
      writer.uint32(16).uint32(message.mapping);
    }
    if (message.count !== "0") {
      writer.uint32(24).uint64(message.count);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mapping = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      mapping: isSet(object.mapping) ? globalThis.Number(object.mapping) : 0,
      count: isSet(object.count) ? globalThis.String(object.count) : "0",
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.mapping !== 0) {
      obj.mapping = Math.round(message.mapping);
    }
    if (message.count !== "0") {
      obj.count = message.count;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry {
    return CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry();
    message.value = object.value ?? 0;
    message.mapping = object.mapping ?? 0;
    message.count = object.count ?? "0";
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry(): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry {
  return { key: 0, value: undefined };
}

export const CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry: MessageFns<
  CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry
> = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value)
        ? CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.fromJSON(object.value)
        : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry {
    return CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry(): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry {
  return { key: 0, value: undefined };
}

export const CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry: MessageFns<
  CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry
> = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value)
        ? CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.fromJSON(object.value)
        : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry {
    return CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_KMeans(): CMsgSteamLearnInferenceMetadataResponse_KMeans {
  return { name: "", clusters: [] };
}

export const CMsgSteamLearnInferenceMetadataResponse_KMeans: MessageFns<
  CMsgSteamLearnInferenceMetadataResponse_KMeans
> = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_KMeans,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.clusters) {
      CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse_KMeans {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_KMeans();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clusters.push(CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_KMeans {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      clusters: globalThis.Array.isArray(object?.clusters)
        ? object.clusters.map((e: any) => CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_KMeans): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.clusters?.length) {
      obj.clusters = message.clusters.map((e) => CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_KMeans>,
  ): CMsgSteamLearnInferenceMetadataResponse_KMeans {
    return CMsgSteamLearnInferenceMetadataResponse_KMeans.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_KMeans>,
  ): CMsgSteamLearnInferenceMetadataResponse_KMeans {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_KMeans();
    message.name = object.name ?? "";
    message.clusters =
      object.clusters?.map((e) => CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster(): CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster {
  return { x: 0, y: 0, radius: 0, radius80pct: 0 };
}

export const CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster: MessageFns<
  CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster
> = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.radius !== 0) {
      writer.uint32(29).float(message.radius);
    }
    if (message.radius80pct !== 0) {
      writer.uint32(37).float(message.radius80pct);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.radius = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.radius80pct = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
      radius80pct: isSet(object.radius80pct) ? globalThis.Number(object.radius80pct) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.radius !== 0) {
      obj.radius = message.radius;
    }
    if (message.radius80pct !== 0) {
      obj.radius80pct = message.radius80pct;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster>,
  ): CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster {
    return CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster>,
  ): CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.radius = object.radius ?? 0;
    message.radius80pct = object.radius80pct ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram(): CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram {
  return { minValue: 0, maxValue: 0, numBuckets: 0, bucketCounts: [] };
}

export const CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram: MessageFns<
  CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram
> = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.minValue !== 0) {
      writer.uint32(13).float(message.minValue);
    }
    if (message.maxValue !== 0) {
      writer.uint32(21).float(message.maxValue);
    }
    if (message.numBuckets !== 0) {
      writer.uint32(24).uint32(message.numBuckets);
    }
    writer.uint32(34).fork();
    for (const v of message.bucketCounts) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.minValue = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.maxValue = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.numBuckets = reader.uint32();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.bucketCounts.push(reader.uint32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.bucketCounts.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram {
    return {
      minValue: isSet(object.minValue) ? globalThis.Number(object.minValue) : 0,
      maxValue: isSet(object.maxValue) ? globalThis.Number(object.maxValue) : 0,
      numBuckets: isSet(object.numBuckets) ? globalThis.Number(object.numBuckets) : 0,
      bucketCounts: globalThis.Array.isArray(object?.bucketCounts)
        ? object.bucketCounts.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram): unknown {
    const obj: any = {};
    if (message.minValue !== 0) {
      obj.minValue = message.minValue;
    }
    if (message.maxValue !== 0) {
      obj.maxValue = message.maxValue;
    }
    if (message.numBuckets !== 0) {
      obj.numBuckets = Math.round(message.numBuckets);
    }
    if (message.bucketCounts?.length) {
      obj.bucketCounts = message.bucketCounts.map((e) => Math.round(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram>,
  ): CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram {
    return CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram>,
  ): CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram();
    message.minValue = object.minValue ?? 0;
    message.maxValue = object.maxValue ?? 0;
    message.numBuckets = object.numBuckets ?? 0;
    message.bucketCounts = object.bucketCounts?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceBackendResponse(): CMsgSteamLearnInferenceBackendResponse {
  return { outputs: [] };
}

export const CMsgSteamLearnInferenceBackendResponse: MessageFns<CMsgSteamLearnInferenceBackendResponse> = {
  encode(message: CMsgSteamLearnInferenceBackendResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.outputs) {
      CMsgSteamLearnInferenceBackendResponse_Output.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnInferenceBackendResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceBackendResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputs.push(CMsgSteamLearnInferenceBackendResponse_Output.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceBackendResponse {
    return {
      outputs: globalThis.Array.isArray(object?.outputs)
        ? object.outputs.map((e: any) => CMsgSteamLearnInferenceBackendResponse_Output.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnInferenceBackendResponse): unknown {
    const obj: any = {};
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => CMsgSteamLearnInferenceBackendResponse_Output.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnInferenceBackendResponse>): CMsgSteamLearnInferenceBackendResponse {
    return CMsgSteamLearnInferenceBackendResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnInferenceBackendResponse>): CMsgSteamLearnInferenceBackendResponse {
    const message = createBaseCMsgSteamLearnInferenceBackendResponse();
    message.outputs = object.outputs?.map((e) => CMsgSteamLearnInferenceBackendResponse_Output.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput(): CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput {
  return { value: 0 };
}

export const CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput: MessageFns<
  CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput
> = {
  encode(
    message: CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(13).float(message.value);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput>,
  ): CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput {
    return CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput>,
  ): CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput {
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput(): CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput {
  return { weight: [], value: [] };
}

export const CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput: MessageFns<
  CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput
> = {
  encode(
    message: CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.weight) {
      writer.float(v);
    }
    writer.join();
    writer.uint32(18).fork();
    for (const v of message.value) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 13) {
            message.weight.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.weight.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 21) {
            message.value.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.value.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput {
    return {
      weight: globalThis.Array.isArray(object?.weight) ? object.weight.map((e: any) => globalThis.Number(e)) : [],
      value: globalThis.Array.isArray(object?.value) ? object.value.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput): unknown {
    const obj: any = {};
    if (message.weight?.length) {
      obj.weight = message.weight;
    }
    if (message.value?.length) {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput>,
  ): CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput {
    return CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput>,
  ): CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput {
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput();
    message.weight = object.weight?.map((e) => e) || [];
    message.value = object.value?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput(): CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput {
  return { weight: [], value: [] };
}

export const CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput: MessageFns<
  CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput
> = {
  encode(
    message: CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.weight) {
      writer.float(v);
    }
    writer.join();
    writer.uint32(18).fork();
    for (const v of message.value) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 13) {
            message.weight.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.weight.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 21) {
            message.value.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.value.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput {
    return {
      weight: globalThis.Array.isArray(object?.weight) ? object.weight.map((e: any) => globalThis.Number(e)) : [],
      value: globalThis.Array.isArray(object?.value) ? object.value.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput): unknown {
    const obj: any = {};
    if (message.weight?.length) {
      obj.weight = message.weight;
    }
    if (message.value?.length) {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput>,
  ): CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput {
    return CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput>,
  ): CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput {
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput();
    message.weight = object.weight?.map((e) => e) || [];
    message.value = object.value?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceBackendResponse_Output(): CMsgSteamLearnInferenceBackendResponse_Output {
  return { binaryCrossentropy: undefined, categoricalCrossentropy: undefined, multiBinaryCrossentropy: undefined };
}

export const CMsgSteamLearnInferenceBackendResponse_Output: MessageFns<CMsgSteamLearnInferenceBackendResponse_Output> =
  {
    encode(
      message: CMsgSteamLearnInferenceBackendResponse_Output,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.binaryCrossentropy !== undefined) {
        CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput.encode(
          message.binaryCrossentropy,
          writer.uint32(10).fork(),
        ).join();
      }
      if (message.categoricalCrossentropy !== undefined) {
        CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput.encode(
          message.categoricalCrossentropy,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.multiBinaryCrossentropy !== undefined) {
        CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput.encode(
          message.multiBinaryCrossentropy,
          writer.uint32(26).fork(),
        ).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnInferenceBackendResponse_Output {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCMsgSteamLearnInferenceBackendResponse_Output();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.binaryCrossentropy = CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.categoricalCrossentropy = CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput
              .decode(reader, reader.uint32());
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.multiBinaryCrossentropy = CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput
              .decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CMsgSteamLearnInferenceBackendResponse_Output {
      return {
        binaryCrossentropy: isSet(object.binaryCrossentropy)
          ? CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput.fromJSON(object.binaryCrossentropy)
          : undefined,
        categoricalCrossentropy: isSet(object.categoricalCrossentropy)
          ? CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput.fromJSON(
            object.categoricalCrossentropy,
          )
          : undefined,
        multiBinaryCrossentropy: isSet(object.multiBinaryCrossentropy)
          ? CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput.fromJSON(
            object.multiBinaryCrossentropy,
          )
          : undefined,
      };
    },

    toJSON(message: CMsgSteamLearnInferenceBackendResponse_Output): unknown {
      const obj: any = {};
      if (message.binaryCrossentropy !== undefined) {
        obj.binaryCrossentropy = CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput.toJSON(
          message.binaryCrossentropy,
        );
      }
      if (message.categoricalCrossentropy !== undefined) {
        obj.categoricalCrossentropy = CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput.toJSON(
          message.categoricalCrossentropy,
        );
      }
      if (message.multiBinaryCrossentropy !== undefined) {
        obj.multiBinaryCrossentropy = CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput.toJSON(
          message.multiBinaryCrossentropy,
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<CMsgSteamLearnInferenceBackendResponse_Output>,
    ): CMsgSteamLearnInferenceBackendResponse_Output {
      return CMsgSteamLearnInferenceBackendResponse_Output.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<CMsgSteamLearnInferenceBackendResponse_Output>,
    ): CMsgSteamLearnInferenceBackendResponse_Output {
      const message = createBaseCMsgSteamLearnInferenceBackendResponse_Output();
      message.binaryCrossentropy = (object.binaryCrossentropy !== undefined && object.binaryCrossentropy !== null)
        ? CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput.fromPartial(object.binaryCrossentropy)
        : undefined;
      message.categoricalCrossentropy =
        (object.categoricalCrossentropy !== undefined && object.categoricalCrossentropy !== null)
          ? CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput.fromPartial(
            object.categoricalCrossentropy,
          )
          : undefined;
      message.multiBinaryCrossentropy =
        (object.multiBinaryCrossentropy !== undefined && object.multiBinaryCrossentropy !== null)
          ? CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput.fromPartial(
            object.multiBinaryCrossentropy,
          )
          : undefined;
      return message;
    },
  };

function createBaseCMsgSteamLearnInferenceResponse(): CMsgSteamLearnInferenceResponse {
  return { inferenceResult: 0, backendResponse: undefined };
}

export const CMsgSteamLearnInferenceResponse: MessageFns<CMsgSteamLearnInferenceResponse> = {
  encode(message: CMsgSteamLearnInferenceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inferenceResult !== 0) {
      writer.uint32(8).int32(message.inferenceResult);
    }
    if (message.backendResponse !== undefined) {
      CMsgSteamLearnInferenceBackendResponse.encode(message.backendResponse, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CMsgSteamLearnInferenceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.inferenceResult = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.backendResponse = CMsgSteamLearnInferenceBackendResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceResponse {
    return {
      inferenceResult: isSet(object.inferenceResult) ? eSteamLearnInferenceResultFromJSON(object.inferenceResult) : 0,
      backendResponse: isSet(object.backendResponse)
        ? CMsgSteamLearnInferenceBackendResponse.fromJSON(object.backendResponse)
        : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceResponse): unknown {
    const obj: any = {};
    if (message.inferenceResult !== 0) {
      obj.inferenceResult = eSteamLearnInferenceResultToJSON(message.inferenceResult);
    }
    if (message.backendResponse !== undefined) {
      obj.backendResponse = CMsgSteamLearnInferenceBackendResponse.toJSON(message.backendResponse);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnInferenceResponse>): CMsgSteamLearnInferenceResponse {
    return CMsgSteamLearnInferenceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnInferenceResponse>): CMsgSteamLearnInferenceResponse {
    const message = createBaseCMsgSteamLearnInferenceResponse();
    message.inferenceResult = object.inferenceResult ?? 0;
    message.backendResponse = (object.backendResponse !== undefined && object.backendResponse !== null)
      ? CMsgSteamLearnInferenceBackendResponse.fromPartial(object.backendResponse)
      : undefined;
    return message;
  },
};

export interface SteamLearn {
  RegisterDataSource(
    request: CMsgSteamLearnRegisterDataSourceRequest,
  ): Promise<CMsgSteamLearnRegisterDataSourceResponse>;
  CacheData(request: CMsgSteamLearnCacheDataRequest): Promise<CMsgSteamLearnCacheDataResponse>;
  SnapshotProject(request: CMsgSteamLearnSnapshotProjectRequest): Promise<CMsgSteamLearnSnapshotProjectResponse>;
  BatchOperation(request: CMsgSteamLearnBatchOperationRequest): Promise<CMsgSteamLearnBatchOperationResponse>;
  GetHMACKeys(request: CMsgSteamLearnGetHMACKeysRequest): Promise<CMsgSteamLearnGetHMACKeysResponse>;
  Inference(request: CMsgSteamLearnInferenceRequest): Promise<CMsgSteamLearnInferenceResponse>;
  InferenceMetadata(request: CMsgSteamLearnInferenceMetadataRequest): Promise<CMsgSteamLearnInferenceMetadataResponse>;
}

export const SteamLearnServiceName = "SteamLearn";
export class SteamLearnClientImpl implements SteamLearn {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || SteamLearnServiceName;
    this.rpc = rpc;
    this.RegisterDataSource = this.RegisterDataSource.bind(this);
    this.CacheData = this.CacheData.bind(this);
    this.SnapshotProject = this.SnapshotProject.bind(this);
    this.BatchOperation = this.BatchOperation.bind(this);
    this.GetHMACKeys = this.GetHMACKeys.bind(this);
    this.Inference = this.Inference.bind(this);
    this.InferenceMetadata = this.InferenceMetadata.bind(this);
  }
  RegisterDataSource(
    request: CMsgSteamLearnRegisterDataSourceRequest,
  ): Promise<CMsgSteamLearnRegisterDataSourceResponse> {
    const data = CMsgSteamLearnRegisterDataSourceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RegisterDataSource", data);
    return promise.then((data) => CMsgSteamLearnRegisterDataSourceResponse.decode(new BinaryReader(data)));
  }

  CacheData(request: CMsgSteamLearnCacheDataRequest): Promise<CMsgSteamLearnCacheDataResponse> {
    const data = CMsgSteamLearnCacheDataRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CacheData", data);
    return promise.then((data) => CMsgSteamLearnCacheDataResponse.decode(new BinaryReader(data)));
  }

  SnapshotProject(request: CMsgSteamLearnSnapshotProjectRequest): Promise<CMsgSteamLearnSnapshotProjectResponse> {
    const data = CMsgSteamLearnSnapshotProjectRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SnapshotProject", data);
    return promise.then((data) => CMsgSteamLearnSnapshotProjectResponse.decode(new BinaryReader(data)));
  }

  BatchOperation(request: CMsgSteamLearnBatchOperationRequest): Promise<CMsgSteamLearnBatchOperationResponse> {
    const data = CMsgSteamLearnBatchOperationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BatchOperation", data);
    return promise.then((data) => CMsgSteamLearnBatchOperationResponse.decode(new BinaryReader(data)));
  }

  GetHMACKeys(request: CMsgSteamLearnGetHMACKeysRequest): Promise<CMsgSteamLearnGetHMACKeysResponse> {
    const data = CMsgSteamLearnGetHMACKeysRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetHMACKeys", data);
    return promise.then((data) => CMsgSteamLearnGetHMACKeysResponse.decode(new BinaryReader(data)));
  }

  Inference(request: CMsgSteamLearnInferenceRequest): Promise<CMsgSteamLearnInferenceResponse> {
    const data = CMsgSteamLearnInferenceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Inference", data);
    return promise.then((data) => CMsgSteamLearnInferenceResponse.decode(new BinaryReader(data)));
  }

  InferenceMetadata(request: CMsgSteamLearnInferenceMetadataRequest): Promise<CMsgSteamLearnInferenceMetadataResponse> {
    const data = CMsgSteamLearnInferenceMetadataRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "InferenceMetadata", data);
    return promise.then((data) => CMsgSteamLearnInferenceMetadataResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
